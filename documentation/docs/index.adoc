= Build a multi-module project with gradle

:imagesdir: resources/
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:important-caption: :heavy_exclamation_mark:
:caution-caption: :fire:
:warning-caption: :warning:
endif::[]

In this article I would like to show how to establish a gradle multi-module project configuration based on gradle 6.8. Browsing through the
whole wide dustbin (uh, www was the correct abbreviation) gives you several solutions and some (if not most) of them are based on older
versions of gradle and/or are written in groovy, but I want to use only the kotlin DSL.

Since I am currently working on a small project, I am using examples from this pure kotlin project. Kotlin has some specifics in the configuration
of gradle as well. One of those is the "internal" visiblity modifier. Classes and/or methods marked with this modifier are not visible outside
of the current module additionally to the test-module. See https://kotlinlang.org/docs/reference/visibility-modifiers.html#modules[kotlin Visibility Modifiers - Modules]
for further information about the definiton of modules. Due to the fact, that we do want to have integration tests using "internal" methods,
we need some additional configuration, which is shown in the following as well.

Basically additional to a small project provided by the `gradle init` action, we are going to add some useful tasks, which are necessary in most
mid-size and larger projects:

* Integration Tests
* Dokka Pages as well as an aggregation of those
* Jacoco Reports (inclusive an aggregated report for all sub-projects)
* Sonarqube Reporting

In another article I am going to explain on how to release such a project using semantic versioning and github-actions using the above mentioned
steps/tasks.

Gradle mandates the usage of "conventions" in the buildSrc-Directory. If you do use a `gradle init`, and generate a multi-module project, some of
those files are already generated automatically. In here we are going to use and extend those files, so that eg. integration tests are supported
as well.

== Install gradle and initialize project

Like already mentioned, we are going to start with `gradle init` to generate a small multi-module project. Unfortunately, even though we are going
to use the gradle wrapper in out project, gradle forces us to install gradle itself, to initialize a project. Therefor your first step is to install
gradle on your local machine. This can be done via your local package manager (Yum, Pacman, Homebrew, Chocolatey, ...) or manually via
https://gradle.org/install/[Gradle Install].

So, after installing gradle, we are going to create a first small project via the beforementioned `gradle init`. We are going to use the following
additional command-line parameters, which are shortly explained as well. For a full description of those parameters please refer to
https://docs.gradle.org/current/userguide/build_init_plugin.html[Gradle Build Init Plugin].

The project is available on https://github.com/triplem/someproject[github], and the result of each step is put into its own branch.

`gradle init --type kotlin-application --dsl kotlin --split-project --project-name article --package org.javafreedom`

This will setup a small project with the type `kotlin-application`, which contains all required components for a kotlin command-line application. Furthermore
we are going to have some provided sub-modules (`split-project`). The project-name is usually taken from the name of the directory. To be able to be
independent of the current directory, we do provide the project-name. The used package is the one used for this example project (`org.javafreedom`). All
of those values can be adopted to your personal taste, obviously. The used dsl is kotlin, which will provide us with *.gradle.kts files instead of the groovy
*.gradle files.

Since we are using the projec-type kotlin-application, the pre-configured test-framework is kotlin.test and, quite obviously, the used language is kotlin.

The following project structure is then generated by the `gradle init`-command:

image::project-structure-init.png[Project Structure after initilization]

Please note the contents of the buildSrc-directory, which shows already three generated conventions. In the following steps, we are going to extend those files,
to be able to fulfill our use-case.

After intializing the project, a first `gradlew tasks` will show a list of all available tasks.

All those changes can also be viewed on https://github.com/triplem/someproject[github]

== change directory structure

I wanted to have all sub-modules gathered in the directory `modules` and therefor all sub-modules (list, ...) are moved to this folder. To be able to discover those
modules automatically, the settings.gradle.kts is adopted slightly.

.settings.gradle.kts
[source,kotlin]
----
fun includeProjectsInDir(dirName: String) {
    file(dirName).listFilesOrdered { it.isDirectory }
        .forEach { dir ->
            include(dir.name)
            val prj = project(":${dir.name}")
            prj.projectDir = dir
            prj.buildFileName = "${dir.name}.gradle.kts"
            require(prj.projectDir.isDirectory) { "Project '${prj.path} must have a ${prj.projectDir} directory" }
            require(prj.buildFile.isFile) { "Project '${prj.path} must have a ${prj.buildFile} build script" }
        }
}

includeProjectsInDir("modules")
----

The above code will basically list all sub-directories of the given directory (modules in this case), and add those directories to the childprojects of the current
project (which is the root). This is rather generic and adds the possiblity of easily add additional modules (even in different parent-direcotries) like eg. a documentation module.
Each project contains an own `.gradle.kts` file, which is named like the containing folder.

image::project-structure-modules-added.png[Project structure with modules added]

All those changes can also be viewed on https://github.com/triplem/someproject[github]

== add additional "useful" dependencies

To be able to write tests, useful logging and other stuff, we do need to provide additional dependencies. Some of those dependencies (like logging) are required
in all sub-modules and we do declare those in a central space, the convention.

I decided to add the following default dependencies for all kotlin sub-modules:

* https://github.com/MicroUtils/kotlin-logging[kotlin logging] to make logging easier
* https://github.com/willowtreeapps/assertk[assertk] for Assertions in Tests
* https://kotlinlang.org/api/latest/kotlin.test/[kotlin.test] for Tests

The common-convention is now containing all the above mentioned additional dependencies. To show off, that those dependencies are
added to the modules, inside the list-module the Class LinkedListTest was renamed to MutableListTest and contains now statements
from those dependencies.

The following code snippet show the additions to the org.javafreedom.kotlin-common-conventions.gradle.kts.


.org.javafreedom.kotlin-common-conventions.gradle.kts
[source,kotlin]
----
// Add additonal dependencies useful for development
implementation("io.github.microutils:kotlin-logging:2.0.4")
testImplementation("com.willowtreeapps.assertk:assertk-jvm:0.23")
testImplementation(kotlin("test"))
testImplementation(kotlin("test-junit5"))
----

All those changes can also be viewed on https://github.com/triplem/someproject?branch=dependencies[github]

== add Dokka generation

In kotlin, the documentation of classes and methods are generated using dokka (similar to javadoc). This documentation should be generated and aggregated in
a common place, so that deverlopers can refer to it. Usually dokka is generated for each sub-module, but not aggregated.

The https://github.com/Kotlin/dokka[dokka plugin] can be found in the jcenter Repository and not, like other plugins, in the gradlePluginPortal(). That means,
that we do need to add this repository to the settings.gradle.kts.

.settings.gradle.kts
[source,kotlin]
----
pluginManagement {
    repositories {
        gradlePluginPortal()
        jcenter()
    }
}
----

It is quite important to add the classpath of this plugin to the buildSrc/build.gradle.kts, to be able to provide a version, which cannot be done
in the conventions-script itself.

.buildSrc/build.gradle.kts
[source,kotlin]
----
implementation("org.jetbrains.dokka:dokka-gradle-plugin:1.4.20")
----

In the convention the plugin can then be used. We also modified the kotlin-jvm plugin to use the DependencyHandler-Extension `kotlin` to make the
statement slightly more readable.

.org.javafreedom.kotlin-common-conventions.gradle.kts
[source,kotlin]
----
plugins {
    // Apply the org.jetbrains.kotlin.jvm Plugin to add support for Kotlin.
    kotlin("jvm")
    id("org.jetbrains.dokka")
}
----

After applying those changes, the `dokkaHtml`-Task is available on all submodules. To show this, some dummy documentation was added to the
LinkedList-Class. The documentation is then generated in the build/dokka/html-Folder of each module.

To be able to aggregate the dokka-generated Documentation, we do need to add a new build.gradle.kts in the root-folder of the project. In this
file the dokkaHtmlMultiModule-Task is declared.

.build.gradle.kts
[source,kotlin]
----
plugins {
    id("org.jetbrains.dokka")
}

repositories {
    jcenter()
}

tasks.dokkaHtmlMultiModule.configure {
    outputDirectory.set(buildDir.resolve("dokkaCustomMultiModuleOutput"))
}
----

It is quite important to set the repoositories, because the dokka plugin tries to load some dependencies from this repository. By calling
the task `dokkaHtmlMultiModule` the dokka-Documentation of all modules is build and then aggregated in the `build/dokkaCustomMultiModuleOutput`
directory.

This step adds the following tasks to the project. Please not especially the *MultiModule-Tasks, which do use the above
mentioned configuration.

[source,bash]
----
Documentation tasks

dokkaGfm - Generates documentation in GitHub flavored markdown format
dokkaGfmCollector - Generates documentation merging all subprojects 'dokkaGfm' tasks into one virtual module
dokkaGfmMultiModule - Runs all subprojects 'dokkaGfm' tasks and generates module navigation page
dokkaHtml - Generates documentation in 'html' format
dokkaHtmlCollector - Generates documentation merging all subprojects 'dokkaHtml' tasks into one virtual module
dokkaHtmlMultiModule - Runs all subprojects 'dokkaHtml' tasks and generates module navigation page
dokkaJavadoc - Generates documentation in 'javadoc' format
dokkaJavadocCollector - Generates documentation merging all subprojects 'dokkaJavadoc' tasks into one virtual module
dokkaJekyll - Generates documentation in Jekyll flavored markdown format
dokkaJekyllCollector - Generates documentation merging all subprojects 'dokkaJekyll' tasks into one virtual module
dokkaJekyllMultiModule - Runs all subprojects 'dokkaJekyll' tasks and generates module navigation page
javadoc - Generates Javadoc API documentation for the main source code.
----

All those changes can also be viewed on https://github.com/triplem/someproject?branch=dokka[github]

== add Integration Tests

In this step, we are going to add the `integrationTest`-Task and the associated SourceSet (named testIntegration) to the proejct. Like already mentioned,
we are going to use conventions. To be able to show some nuts and bolts, we are also adding some additonal classes, so that we can show, that this task can
also use classes marked with the `internal` visibility modifier.

The https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_additional_test_types.html[gradle Manual] offered quite some help here. For a better
readability of the project structure (meaning: for a better sorting of folders in the project structure), the 'integrationTest' sourceSet is renamed to
'testIntegration'. This will show the testIntegration-Source-directory after the test-folder, which will make the structure clearer IMHO.

To get rid of an "Overload resolution ambiquity"-Message, the following statement is added. This makes sure, that the sourceSets are of the correct type
and the ambiguity is resolved.

.org.javafreedom.kotlin-common-conventions.gradle.kts
[source,kotlin]
----
// to get rid of "Overload resolution ambiguity"-messsage
val sourcesets = project.extensions.getByType(SourceSetContainer::class)
val testIntegration by sourcesets.creating
----

One additional step is required to be able to use `internal` classes in the tests.

.org.javafreedom.kotlin-common-conventions.gradle.kts
[source,kotlin]
----
val koTarget = kotlin.target as KotlinTarget
koTarget.compilations.getByName("testIntegration") {
    associateWith(target.compilations.getByName("main"))
}
----

Unfortunately, IntelliJ does not seem to recognize this association, and therefor these classes cannot get automatically resolved in the
Editor. This seems to be a known issue, which is currently worked on (see their https://youtrack.jetbrains.com/issue/KT-17659[Bug-Tracker]
for this).

Additionally this steps provides a task to aggregate the test-reports of all sub-modules. This is heavily based on
https://docs.gradle.org/current/userguide/java_testing.html#test_reporting[gradle Test-Reporting].

Just one line needs to get added to the "binaryTestResultElements"-Configuration, to be able to aggregate the testIntegration-Reports
as well.

.org.javafreedom.kotlin-common-conventions.gradle.kts
[source,kotlin]
----
outgoing.artifact(testIntegrationTask.map { task -> task.getBinaryResultsDirectory().get() })
----

This step adds the following tasks to the project

[source,bash]
----
Verification tasks

integrationTest - Runs integration tests.
----

On running the `integrationTest`-Task on the project, all Integration-Test are run and a report is generated in the build/reports/allTests-Folder
which does contain the results of all Tests in the project.

All those changes can also be viewed on https://github.com/triplem/someproject?branch=dokka[github]

== add Jacoco

Like the dokka documentation, the jacccoco Reports are generated per sub-module, and are then going to get aggregated in the root of the project. We do need to add
the Report generation, as well as the report aggregation into our small project.

== Conclusion

This small post shows, that a kotlin project using gradle can be adopted quite easily to the extended requirements usually found in growing software projects.
The usage of the kotlin-dsl can improve type-safty but on the other hand, does make some documentation, which can be found in the open, quite hard to adopt
to a new project. But with conventions and the best-practices from the gradle-community the build stays out-of-the way of the developers while still being able
to fulfill all needs.

The buildSrc-Conventions do offer a great deal of flexibility but still provide some best-practices to a software project. My recommendation is to use this toolset.
If you do have larger projects, it could make sense to use own plugins to provide this funtionality, but for small to mid-size projects this approach seems to be
a best fit.
